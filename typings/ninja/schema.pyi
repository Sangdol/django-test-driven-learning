"""
This type stub file was generated by pyright.
"""

from typing import Any, Callable, Dict, Type, TypeVar, Union, no_type_check
from pydantic import BaseModel
from pydantic.main import ModelMetaclass
from pydantic.utils import GetterDict

"""
Since "Model" word would be very confusing when used in django context, this
module basically makes an alias for it named "Schema" and adds extra whistles to
be able to work with django querysets and managers.

The schema is a bit smarter than a standard pydantic Model because it can handle
dotted attributes and resolver methods. For example::


    class UserSchema(User):
        name: str
        initials: str
        boss: str = Field(None, alias="boss.first_name")

        @staticmethod
        def resolve_name(obj):
            return f"{obj.first_name} {obj.last_name}"

        def resolve_initials(self, obj):
            return "".join(n[:1] for n in self.name.split())

"""
pydantic_version = ...
__all__ = ["BaseModel", "Field", "validator", "DjangoGetter", "Schema"]
S = TypeVar("S", bound="Schema")
class DjangoGetter(GetterDict):
    __slots__ = ...
    def __init__(self, obj: Any, schema_cls: Type[Schema]) -> None:
        ...
    
    def __getitem__(self, key: str) -> Any:
        ...
    
    def get(self, key: Any, default: Any = ...) -> Any:
        ...
    


class Resolver:
    __slots__ = ...
    _static: bool
    _func: Any
    def __init__(self, func: Union[Callable, staticmethod]) -> None:
        ...
    
    def __call__(self, getter: DjangoGetter) -> Any:
        ...
    


class ResolverMetaclass(ModelMetaclass):
    _ninja_resolvers: Dict[str, Resolver]
    @no_type_check
    def __new__(cls, name, bases, namespace, **kwargs): # -> Self@ResolverMetaclass:
        ...
    


class Schema(BaseModel, metaclass=ResolverMetaclass):
    class Config:
        orm_mode = ...
        getter_dict = DjangoGetter
    
    
    @classmethod
    def from_orm(cls: Type[S], obj: Any) -> S:
        ...
    


